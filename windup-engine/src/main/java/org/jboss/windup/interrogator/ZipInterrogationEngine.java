/*
 * Copyright (c) 2013 Red Hat, Inc. and/or its affiliates.
 *  
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *  
 *  Contributors:
 *      Brad Davis - bradsdavis@gmail.com - Initial API and implementation
 */
package org.jboss.windup.interrogator;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.zip.ZipFile;

import org.apache.commons.io.FileUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jboss.windup.interrogator.impl.DecoratorPipeline;
import org.jboss.windup.resource.type.archive.ArchiveMeta;
import org.jboss.windup.resource.type.archive.ZipMeta;
import org.jboss.windup.util.RecursiveZipMetaFactory;

/**
 * Takes the Interrogators, and applies them against the ZipMeta. It then
 * collects the results, which are returned as an ArchiveResult.
 * 
 * @author bdavis
 * 
 */
public class ZipInterrogationEngine {
	private static final Log LOG = LogFactory.getLog(ZipInterrogationEngine.class);

	private static final String TEMP_DIR_EXTENSION = ".windup.tmp";

	protected RecursiveZipMetaFactory recursiveExtractor;
	protected DecoratorPipeline<ZipMeta> decoratorPipeline;

	public void setDecoratorPipeline(DecoratorPipeline<ZipMeta> decoratorPipeline) {
		this.decoratorPipeline = decoratorPipeline;
	}

	public void setRecursiveExtractor(RecursiveZipMetaFactory recursiveExtractor) {
		this.recursiveExtractor = recursiveExtractor;
	}

	/**
	 * <p>
	 * Processes the given target archive to the given output directory.
	 * </p>
	 * 
	 * <p>
	 * If no output directory is specified a temporary output location will be
	 * created during processing, because it is needed, and then deleted before
	 * processing returns.
	 * </p>
	 * 
	 * @param outputDirectory
	 *            Optional. Output directory to process the target archive too
	 * @param targetArchive
	 *            to process
	 * @param parentMeta
	 *            Optional. {@link ArchiveMeta} to use as parent for the new
	 *            {@link ZipMeta} generated by processing the target archive
	 * 
	 * @return {@link ZipMeta} gained from processing the given target archive
	 */
	public ZipMeta process(File outputDirectory, File targetArchive, ArchiveMeta parentMeta) {
		if (targetArchive == null) {
			throw new IllegalArgumentException("targetArchive cannot be null");
		}

		ZipMeta archiveMeta;
		LOG.info("Processing: " + targetArchive.getName());
		try {
			ZipFile zf = new ZipFile(targetArchive);
			archiveMeta = recursiveExtractor.recursivelyExtract(parentMeta, zf);
		} catch (Exception e) {
			LOG.error("Error unzipping file.", e);
			return null;
		}

		List<ZipMeta> archiveMetas = new LinkedList<ZipMeta>();
		unfoldRecursion(archiveMeta, archiveMetas);

		int i = 1;
		int j = archiveMetas.size();

		/* if outputDirectory is not null use that as the parent out directory
		 * else create a temp directory to be deleted later */
		File archiveParentOutputDir;
		if(outputDirectory != null) {
			archiveParentOutputDir = outputDirectory;
		} else {
			archiveParentOutputDir = new File(targetArchive.getParent() + File.separator + targetArchive.getName() + TEMP_DIR_EXTENSION);
		}
		
		//process the archives
		for (ZipMeta archive : archiveMetas) {
			LOG.info("Interrogating (" + i + " of " + j + "): " + archive.getRelativePath());

			archive.setArchiveOutputDirectory(new File(archiveParentOutputDir + File.separator + archive.getRelativePath()));

			decoratorPipeline.processMeta(archive);
			i++;
		}
		
		// if no specified outputDirectory delete the temporary one
		if(outputDirectory == null) {
			try {
				FileUtils.deleteDirectory(archiveParentOutputDir);
			} catch (IOException e) {
				LOG.error("Error deleting temporary directory used for processing a Zip archive", e);
			}
		}

		recursiveExtractor.releaseTempFiles();
		return archiveMeta;
	}

	protected void unfoldRecursion(ZipMeta base, Collection<ZipMeta> archiveMetas) {
		for (ArchiveMeta meta : base.getNestedArchives()) {
			ZipMeta zipMeta = (ZipMeta) meta;

			unfoldRecursion(zipMeta, archiveMetas);
		}
		archiveMetas.add(base);
	}
}